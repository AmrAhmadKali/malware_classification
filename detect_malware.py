import random
from datetime import datetime

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision import datasets, transforms, models
from torchvision.utils import make_grid
from config import *
import numpy as np
from models.CnnModels import *
from data_utils.data_loaders import *
from utils import *
from tqdm import tqdm


def setup():
    global device, LOG_DIR
    device = torch.device("cuda" if use_cuda else "cpu")
    current_time_str = str(datetime.now().strftime("%d-%b-%Y_%H_%M_%S"))
    LOG_DIR = os.path.join('logs', current_time_str)
    os.makedirs(LOG_DIR)


def execute_cnn_malware_detect(model_params):
    batch_size = model_params['batch_size']
    image_dim = model_params['image_dim']
    epochs = model_params['epochs']
    lr = model_params['lr']

    train_loader, val_loader, dataset_len, class_names = get_data_loaders(data_path=ORG_DATASET64_PATH,
                                                                          image_dim=image_dim,
                                                                          batch_size=batch_size)

    train_set_len = len(train_loader) * batch_size
    val_set_len = len(val_loader) * batch_size
    num_of_classes = len(class_names)

    print(f'Training images available: {train_set_len}')
    print(f'Validation images available: {val_set_len}')
    print(f'Total images available: {dataset_len}')
    print(f'Number of classes: {num_of_classes}')

    model = CNNMalware(image_dim=image_dim, num_of_classes=num_of_classes).to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    save_model_to_log(model, model_params, LOG_DIR)

    train_losses = []
    train_accuracy = []

    tqdm_train_descr_format = "Training model: Accuracy = {:02.4f}%, Loss = {:.4f}"
    tqdm_train_descr = tqdm_train_descr_format.format(0, float('inf'))
    tqdm_train_obj = tqdm(range(epochs), desc=tqdm_train_descr)
    for i in tqdm_train_obj:
        trn_corr = 0
        tst_corr = 0

        # Run the training batches
        for b, (X_train, y_train) in enumerate(train_loader):
            b += 1
            X_train = X_train.to(device)
            y_train = y_train.to(device)
            # Apply the model
            y_pred = model(X_train)
            loss = criterion(y_pred, y_train)

            # Tally the number of correct predictions
            predicted = torch.max(y_pred.data, 1)[1]

            batch_corr = (predicted == y_train).sum()
            trn_corr += batch_corr

            # Update parameters
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

        current_accuracy = trn_corr.item() * 100 / (batch_size * b)
        train_losses.append(loss.item())
        train_accuracy.append(current_accuracy)

        tqdm_descr = tqdm_train_descr_format.format(current_accuracy, loss.item())
        tqdm_train_obj.set_description(tqdm_descr)

    # Run the testing batches
    tst_loss = 0
    tqdm_test_descr_format = "Testing model: Accuracy = {:02.4f}%"
    tqdm_test_descr = tqdm_test_descr_format.format(0)
    tqdm_test_obj = tqdm(val_loader, desc=tqdm_test_descr)

    with torch.no_grad():
        for b, (X_test, y_test) in enumerate(tqdm_test_obj):
            X_test = X_test.to(device)
            y_test = y_test.to(device)

            # Apply the model
            y_val = model(X_test)

            # Tally the number of correct predictions
            predicted = torch.max(y_val.data, 1)[1]
            tst_corr += (predicted == y_test).sum()
            tst_loss += criterion(y_val, y_test)

            tst_corr = tst_corr.item()
            test_accuracy = tst_corr * 100 / (len(val_loader) * batch_size)

            tqdm_test_descr = tqdm_test_descr_format.format(test_accuracy)
            tqdm_test_obj.set_description(tqdm_test_descr)

    print(f'Test accuracy: {test_accuracy:7.4f}%')


def process_deep_learning():
    model_params = {
        'batch_size': 256,
        'image_dim': 32,
        'epochs': 2,
        'lr': 0.001
    }
    execute_cnn_malware_detect(model_params)


def main():
    process_deep_learning()


def print_banner():
    if use_cuda:
        print('Using GPU:', torch.cuda.get_device_name(torch.cuda.current_device()))
    else:
        print('Running on :', device)

    print(f'LOG_DIR = {LOG_DIR}')


if __name__ == '__main__':
    setup()
    print_banner()
    main()
