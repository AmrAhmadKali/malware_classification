import random
from datetime import datetime

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision import datasets, transforms, models
from torchvision.utils import make_grid
from config import *
import numpy as np
from models.CnnModels import *
from data_utils.data_loaders import *
from utils import *


def setup():
    global device, LOG_DIR
    device = torch.device("cuda" if use_cuda else "cpu")
    current_time_str = str(datetime.now().strftime("%d-%b-%Y_%H_%M_%S"))
    LOG_DIR = os.path.join('logs', current_time_str)
    os.makedirs(LOG_DIR)


def execute_cnn_malware_detect(model_params):
    batch_size = model_params['batch_size']
    image_dim = model_params['image_dim']
    epochs = model_params['epochs']
    lr = model_params['lr']

    train_loader, val_loader, dataset_len, class_names = get_data_loaders(data_path=ORG_DATASET64_PATH,
                                                                          image_dim=image_dim,
                                                                          batch_size=batch_size)

    train_set_len = len(train_loader) * batch_size
    val_set_len = len(val_loader) * batch_size
    num_of_classes = len(class_names)

    print(f'Training images available: {train_set_len}')
    print(f'Validation images available: {val_set_len}')
    print(f'Total images available: {dataset_len}')
    print(f'num_of_classes: {num_of_classes}')

    model = CNNMalware(image_dim=image_dim, num_of_classes=num_of_classes).to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    save_model_to_log(model, model_params, LOG_DIR)
    for i in range(epochs):
        trn_corr = 0
        tst_corr = 0

        # Run the training batches
        for b, (X_train, y_train) in enumerate(train_loader):
            b += 1

            X_train = X_train.to(device)
            y_train = y_train.to(device)
            # Apply the model
            y_pred = model(X_train)
            loss = criterion(y_pred, y_train)

            # Tally the number of correct predictions
            predicted = torch.max(y_pred.data, 1)[1]

            batch_corr = (predicted == y_train).sum()
            trn_corr += batch_corr

            # Update parameters
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            # Print interim results
            if b % 10 == 0:
                print(
                    f'epoch: {i:2} batch: {b:4} [{batch_size * b:6}/{train_set_len}]  ' +
                    f'loss: {loss.item():.8f} accuracy: {trn_corr.item() * 100 / (batch_size * b):7.3f}%'
                )

        # Run the testing batches
        with torch.no_grad():
            for b, (X_test, y_test) in enumerate(val_loader):
                X_test = X_test.to(device)
                y_test = y_test.to(device)

                # Apply the model
                y_val = model(X_test)

                # Tally the number of correct predictions
                predicted = torch.max(y_val.data, 1)[1]
                tst_corr += (predicted == y_test).sum()

        loss = criterion(y_val, y_test)


def process_deep_learning():
    model_params = {
        'batch_size': 256,
        'image_dim': 32,
        'epochs': 500,
        'lr': 0.001
    }
    execute_cnn_malware_detect(model_params)


def main():
    process_deep_learning()


def print_banner():
    if use_cuda:
        print('Using GPU:', torch.cuda.get_device_name(torch.cuda.current_device()))
    else:
        print('Running on :', device)

    print(f'LOG_DIR = {LOG_DIR}')


if __name__ == '__main__':
    setup()
    print_banner()
    main()
