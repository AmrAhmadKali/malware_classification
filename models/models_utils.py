from models.CnnModels import *
from models.AnnModels import *
from models.RnnModels import *
from models.TransferLearnModels import *
from data_utils.data_loaders import *
from models.model_trainers_testers import *
from sklearn.model_selection import GridSearchCV
import xgboost as xgb
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
import itertools


def get_deep_rnn_expr_list(print_grid=True, simple_list=False):
    """
    sample template:
            {
            'experiment_name': 'rnn_experiment_1',
            'model_name': 'RNNMalware_Model1',
            'batch_size': 512,
            'embedding_dim': 256,
            'hidden_dim': 128,
            'epochs': 50,
            'lr': 0.0001,
            'num_layers': 1,
            'bidirectional': False,
            'dropout': 0,
            'LG': False
        }

    supported models so far :
    (1) RNNMalware_Model1 :
    (2) LSTMMalware_Model1 :
    (3) GRUMalware_Model1 :
    (4) StackedMalware_Model1 : Stack of LSTM and GRU layers.

            if LG=True => LSTM at bottom and GRU on top, e.g.
                    +---------+
                    |  GRUs   |
                    ----------|
                    |  LSTMs  |
                    +---------+
            else:
                    +---------+
                    |  LSTMs  |
                    ----------|
                    |  GRUs   |
                    +---------+

    """
    get_deep_rnn_expr_grid = {
        'model_name': ['LSTMMalware_Model1', 'GRUMalware_Model1', 'StackedMalware_Model1'],
        'batch_size': [128],
        'embedding_dim': [256, 1024],
        'hidden_dim': [256, 1024],
        'epochs': [20],
        'lr': [0.001],
        'num_layers': [1, 3],
        'bidirectional': [True, False],
        'dropout': [0.3],
        'LG': [True]
    }

    if not simple_list and print_grid:
        print_line()
        print(f'Experiments Grid')
        print(get_deep_rnn_expr_grid)
        print_line()

    if simple_list:
        get_deep_rnn_expr_list = [
            {'model_name': 'StackedMalware_Model1', 'batch_size': 128, 'embedding_dim': 8, 'hidden_dim': 8, 'epochs': 2,
             'lr': 0.001, 'num_layers': 3, 'bidirectional': True, 'dropout': 0.3, 'LG': True,
             'experiment_name': 'rnn_experiment_11'}
        ]
        return get_deep_rnn_expr_list
    else:
        keys, values = zip(*get_deep_rnn_expr_grid.items())
        permutations_dicts = []
        count = 1
        for v in itertools.product(*values):
            temp_dict = dict(zip(keys, v))
            temp_exp = 'rnn_experiment_' + str(count)
            temp_dict['experiment_name'] = temp_exp
            permutations_dicts.append(temp_dict)
            count += 1

        return permutations_dicts


def get_deep_feedforward_expr_list(print_grid=True, simple_list=False):
    """
    Generate list of dictionary with following format
    {
            'experiment_name': 'experiment_3',
            'model_name': 'ANNMalware_Model2',
            'batch_size': 2,
            'image_dim': 256,
            'epochs': 5,
            'lr': 0.001
    }
    """
    get_deep_feedforward_expr_grid = {
        'model_name': ['CNNMalware_Model4'],
        'batch_size': [512],
        'image_dim': [0],
        'epochs': [15],
        'lr': [0.001],
        'conv1d_image_dim_w': [1024 * 4],
        'c1_out': [64, 128],
        'c1_kernel': [16, 32],
        'c1_padding': [2],
        'c1_stride': [2, 8],
        'c2_out': [32, 64, 128],
        'c2_kernel': [8, 16],
        'c2_padding': [2],
        'c2_stride': [2, 4]
    }

    if not simple_list and print_grid:
        print_line()
        print(f'Experiments Grid')
        print(get_deep_feedforward_expr_grid)
        print_line()

    if simple_list:
        get_deep_feedforward_expr_list = [
            {'model_name': 'CNNMalware_Model4', 'batch_size': 256, 'image_dim': 0, 'epochs': 20, 'lr': 0.001,
             'conv1d_image_dim_w': 4096, 'experiment_name': 'conv1d_experiment_2'}

        ]
        return get_deep_feedforward_expr_list
    else:
        keys, values = zip(*get_deep_feedforward_expr_grid.items())
        permutations_dicts = []
        count = 1
        for v in itertools.product(*values):
            temp_dict = dict(zip(keys, v))
            temp_exp = 'experiment_' + str(count)
            temp_dict['experiment_name'] = temp_exp
            permutations_dicts.append(temp_dict)
            count += 1

        return permutations_dicts


def get_shallow_expr_list():
    list_shallow_expr = [
        {
            'experiment_name': 'XGB_experiment_1',
            'model_name': 'XGB',
            'param_grid': {
                'max_depth': [5, 15, 20, 50, 100],
                'learning_rate': [0.1, 0.01, 0.001],
                'n_estimators': list(range(10, 500, 50)),
            }
        },
        {
            'experiment_name': 'RandomForest_experiment_1',
            'model_name': 'RandomForest',
            'param_grid': {
                'criterion': ['gini', 'entropy'],
                'n_estimators': [10, 40, 100, 500],
            }
        },
        {
            'experiment_name': 'Knn_experiment_1',
            'model_name': 'Knn',
            'param_grid': {
                'n_neighbors': list(range(1, 100, 2)),
                'p': [1, 2],
            }
        },
        {
            'experiment_name': 'Knn_experiment_2',
            'model_name': 'Knn',
            'param_grid': {
                'n_neighbors': list(range(1, 100, 2)),
                'p': [2],
            }
        }
    ]

    return list_shallow_expr


def get_conv_transfer_learning_expr_list():
    list_tl_expr = [
        {
            'experiment_name': 'tl_experiment_1',
            'model_name': 'vgg19',
            'batch_size': 256,
            'image_dim': 256,
            'epochs': 20,
            'lr': 0.001
        }
    ]

    return list_tl_expr


def get_malware_experiments_list(expr_type):
    expr_list = None
    if expr_type == DEEP_FF:
        expr_list = get_deep_feedforward_expr_list()
    if expr_type == DEEP_RNN:
        expr_list = get_deep_rnn_expr_list()
    if expr_type == SHALLOW_ML:
        expr_list = get_shallow_expr_list()

    if expr_list is None:
        raise Exception('Unknown experiment type')
    else:
        return expr_list


def create_deep_image_model(model_params):
    image_dim = model_params['image_dim']
    num_of_classes = model_params['num_of_classes']
    model_name = model_params['model_name']

    model = None
    if model_name == 'CNNMalware_Model1':
        model = CNNMalware_Model1(image_dim=image_dim, num_of_classes=num_of_classes).to(device)
    if model_name == 'CNNMalware_Model2':
        model = CNNMalware_Model2(image_dim=image_dim, num_of_classes=num_of_classes).to(device)

    if model_name == 'CNNMalware_Model3':
        conv1d_image_dim_w = model_params['conv1d_image_dim_w']
        model = CNNMalware_Model3(image_dim_w=conv1d_image_dim_w, num_of_classes=num_of_classes).to(device)

    if model_name == 'CNNMalware_Model4':
        conv1d_image_dim_w = model_params['conv1d_image_dim_w']
        c1_out = model_params['c1_out']
        c1_kernel = model_params['c1_kernel']
        c1_padding = model_params['c1_padding']
        c1_stride = model_params['c1_stride']

        c2_out = model_params['c2_out']
        c2_kernel = model_params['c2_kernel']
        c2_padding = model_params['c2_padding']
        c2_stride = model_params['c2_stride']

        model = CNNMalware_Model4(image_dim_w=conv1d_image_dim_w, num_of_classes=num_of_classes,
                                  c1_out=c1_out, c1_kernel=c1_kernel, c1_padding=c1_padding, c1_stride=c1_stride,
                                  c2_out=c2_out, c2_kernel=c2_kernel, c2_padding=c2_padding, c2_stride=c2_stride,
                                  ).to(device)

    if model_name == 'ANNMalware_Model1':
        model = ANNMalware_Model1(image_dim=image_dim, num_of_classes=num_of_classes).to(device)
    if model_name == 'ANNMalware_Model2':
        model = ANNMalware_Model2(image_dim=image_dim, num_of_classes=num_of_classes).to(device)

    if model is None:
        raise Exception("Unknown Deep image model name given")
    return model


def get_pretrained_image_dim(model_name):
    if model_name == 'resnet152':
        return 224
    if model_name == 'vgg19':
        return 224
    raise Exception("Unknown model name given for tl")


def create_deep_opcode_model(model_params):
    input_dim = model_params['input_dim']
    output_dim = model_params['output_dim']
    embedding_dim = model_params['embedding_dim']
    hidden_dim = model_params['hidden_dim']
    batch_size = model_params['batch_size']
    num_of_classes = model_params['num_of_classes']
    model_name = model_params['model_name']
    num_layers = model_params['num_layers']
    bidirectional = model_params['bidirectional']
    dropout = model_params['dropout']

    model = None
    if model_name == 'RNNMalware_Model1':
        model = RNNMalware_Model1(input_dim=input_dim, embedding_dim=embedding_dim, hidden_dim=hidden_dim,
                                  output_dim=output_dim, batch_size=batch_size,
                                  num_layers=num_layers, bidirectional=bidirectional, dropout=dropout)

    if model_name == 'LSTMMalware_Model1':
        model = LSTMMalware_Model1(input_dim=input_dim, embedding_dim=embedding_dim, hidden_dim=hidden_dim,
                                   output_dim=output_dim, batch_size=batch_size,
                                   num_layers=num_layers, bidirectional=bidirectional, dropout=dropout)

    if model_name == 'GRUMalware_Model1':
        model = GRUMalware_Model1(input_dim=input_dim, embedding_dim=embedding_dim, hidden_dim=hidden_dim,
                                  output_dim=output_dim, batch_size=batch_size,
                                  num_layers=num_layers, bidirectional=bidirectional, dropout=dropout)

    if model_name == 'StackedMalware_Model1':
        LG = model_params['LG']
        model = StackedMalware_Model1(input_dim=input_dim, embedding_dim=embedding_dim, hidden_dim=hidden_dim,
                                      output_dim=output_dim, batch_size=batch_size,
                                      num_layers=num_layers, bidirectional=bidirectional, dropout=dropout, LG=LG)

    if model is None:
        raise Exception("Unknown RNN Model name given")

    return model


def create_deep_model(model_params):
    model = None
    if 'image_dim' in model_params.keys():
        model = create_deep_image_model(model_params)
    else:
        model = create_deep_opcode_model(model_params)

    if model is None:
        raise Exception("Unknown Model name given")
    return model


def create_conv_tl_model(model_params):
    model = None
    model_name = model_params['model_name']
    print(f'Creating model {model_name}')
    if model_name == 'resnet152':
        model = Resnet152_wrapper(model_params)
        print(model)
    if model_name == 'vgg19':
        model = VGG19_wrapper(model_params)
        print(model)
    if model is None:
        raise Exception("Unknown Model name given")
    return model


def create_shallow_model(model_params=None):
    model_name = model_params['model_name']
    param_grid = model_params['param_grid']
    model = None
    gsc = None

    if model_name == 'XGB':
        model = xgb.XGBClassifier()
    if model_name == 'RandomForest':
        model = RandomForestClassifier()
    if model_name == 'Knn':
        model = KNeighborsClassifier()

    gsc = GridSearchCV(estimator=model, param_grid=param_grid,
                       cv=5, scoring='accuracy', verbose=1, n_jobs=-1, refit=True)
    if model is None or gsc is None:
        raise Exception("Unknown Model name given")
    return model, gsc
