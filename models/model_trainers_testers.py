import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torchvision import datasets, transforms, models
from torchvision.utils import make_grid
from config import *
import numpy as np
from models.CnnModels import *
from data_utils.data_loaders import *
from utils import *
from tqdm import tqdm


def train_ann_model(model=None, model_params=None, criterion=None,
                    train_loader=None, log_dir=None):
    batch_size = model_params['batch_size']
    image_dim = model_params['image_dim']
    epochs = model_params['epochs']
    lr = model_params['lr']
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    train_losses = []
    train_accuracy = []

    tqdm_train_descr_format = "Training model: Accuracy = {:02.4f}%, Loss = {:.4f}"
    tqdm_train_descr = tqdm_train_descr_format.format(0, float('inf'))
    tqdm_train_obj = tqdm(range(epochs), desc=tqdm_train_descr)

    model.train(True)
    for i in tqdm_train_obj:
        trn_corr = 0

        # Run the training batches
        for b, (X_train, y_train) in enumerate(train_loader):
            b += 1
            X_train = X_train.to(device)
            y_train = y_train.to(device)
            # Apply the model
            y_pred = model(X_train)
            loss = criterion(y_pred, y_train)

            # Tally the number of correct predictions
            predicted = torch.max(y_pred.data, 1)[1]

            batch_corr = (predicted == y_train).sum()
            trn_corr += batch_corr

            # Update parameters
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

        current_accuracy = trn_corr.item() * 100 / (batch_size * b)
        train_losses.append(loss.item())
        train_accuracy.append(current_accuracy)

        tqdm_descr = tqdm_train_descr_format.format(current_accuracy, loss.item())
        tqdm_train_obj.set_description(tqdm_descr)

    return model, train_losses, train_accuracy


def test_ann_model(model=None, model_params=None, criterion=None,
                   val_loader=None):
    batch_size = model_params['batch_size']
    tqdm_test_descr_format = "Testing model: Accuracy = {:02.4f}%"
    tqdm_test_descr = tqdm_test_descr_format.format(0)
    tqdm_test_obj = tqdm(val_loader, desc=tqdm_test_descr)
    model.eval()

    tst_loss = 0
    tst_corr = 0
    predicted_all = torch.tensor([], dtype=torch.long, device=device)
    ground_truth_all = torch.tensor([], dtype=torch.long, device=device)
    num_of_classes = model_params['num_of_classes']
    cm_t = torch.zeros(num_of_classes, num_of_classes)

    with torch.no_grad():
        for b, (X_test, y_test) in enumerate(tqdm_test_obj):
            X_test = X_test.to(device)
            y_test = y_test.to(device)

            # Apply the model
            y_val = model(X_test)

            # Tally the number of correct predictions
            predicted = torch.max(y_val.data, 1)[1]
            tst_corr += (predicted == y_test).sum()
            tst_loss += criterion(y_val, y_test)

            predicted_all = torch.cat((predicted_all, predicted), 0)
            ground_truth_all = torch.cat((ground_truth_all, y_test), 0)

            tst_corr = tst_corr.item()
            test_accuracy = tst_corr * 100 / (len(val_loader) * batch_size)

            for t, p in zip(y_test.view(-1), predicted.view(-1)):
                cm_t[t.long(), p.long()] += 1

            tqdm_test_descr = tqdm_test_descr_format.format(test_accuracy)
            tqdm_test_obj.set_description(tqdm_test_descr)

    predicted_all = predicted_all.cpu().numpy()
    ground_truth_all = ground_truth_all.cpu().numpy()

    return test_accuracy, predicted_all, ground_truth_all

